//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AbpApiDefinitionServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition(includeTypes?: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApiDefinition(_response);
        });
    }

    protected processApiDefinition(response: AxiosResponse): Promise<ApplicationApiDescriptionModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
            return Promise.resolve<ApplicationApiDescriptionModel>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationApiDescriptionModel>(null as any);
    }
}

export class AbpApplicationConfigurationServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param includeLocalizationResources (optional) 
     * @return Success
     */
    applicationConfiguration(includeLocalizationResources?: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration?";
        if (includeLocalizationResources === null)
            throw new Error("The parameter 'includeLocalizationResources' cannot be null.");
        else if (includeLocalizationResources !== undefined)
            url_ += "IncludeLocalizationResources=" + encodeURIComponent("" + includeLocalizationResources) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationConfiguration(_response);
        });
    }

    protected processApplicationConfiguration(response: AxiosResponse): Promise<ApplicationConfigurationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationConfigurationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationConfigurationDto>(null as any);
    }
}

export class AbpApplicationLocalizationServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param onlyDynamics (optional) 
     * @return Success
     */
    applicationLocalization(cultureName: string, onlyDynamics?: boolean | undefined, cancelToken?: CancelToken | undefined): Promise<ApplicationLocalizationDto> {
        let url_ = this.baseUrl + "/api/abp/application-localization?";
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined and cannot be null.");
        else
            url_ += "CultureName=" + encodeURIComponent("" + cultureName) + "&";
        if (onlyDynamics === null)
            throw new Error("The parameter 'onlyDynamics' cannot be null.");
        else if (onlyDynamics !== undefined)
            url_ += "OnlyDynamics=" + encodeURIComponent("" + onlyDynamics) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationLocalization(_response);
        });
    }

    protected processApplicationLocalization(response: AxiosResponse): Promise<ApplicationLocalizationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationLocalizationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationLocalizationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationLocalizationDto>(null as any);
    }
}

export class AbpTenantServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    byName(name: string, cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByName(_response);
        });
    }

    protected processByName(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * @return Success
     */
    byId(id: string, cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processById(_response);
        });
    }

    protected processById(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }
}

export class AccountServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterDto | undefined, cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body?: SendPasswordResetCodeDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-password-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendPasswordResetCode(_response);
        });
    }

    protected processSendPasswordResetCode(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyPasswordResetToken(body?: VerifyPasswordResetTokenInput | undefined, cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/verify-password-reset-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyPasswordResetToken(_response);
        });
    }

    protected processVerifyPasswordResetToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class EmailSettingsServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    emailingGET( cancelToken?: CancelToken | undefined): Promise<EmailSettingsDto> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailingGET(_response);
        });
    }

    protected processEmailingGET(response: AxiosResponse): Promise<EmailSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EmailSettingsDto.fromJS(resultData200);
            return Promise.resolve<EmailSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    emailingPOST(body?: UpdateEmailSettingsDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailingPOST(_response);
        });
    }

    protected processEmailingPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body?: SendTestEmailInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing/send-test-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTestEmail(_response);
        });
    }

    protected processSendTestEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FeaturesServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresGET(providerName?: string | undefined, providerKey?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetFeatureListResultDto> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesGET(_response);
        });
    }

    protected processFeaturesGET(response: AxiosResponse): Promise<GetFeatureListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetFeatureListResultDto.fromJS(resultData200);
            return Promise.resolve<GetFeatureListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetFeatureListResultDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    featuresPUT(providerName?: string | undefined, providerKey?: string | undefined, body?: UpdateFeaturesDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesPUT(_response);
        });
    }

    protected processFeaturesPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresDELETE(providerName?: string | undefined, providerKey?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesDELETE(_response);
        });
    }

    protected processFeaturesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PermissionsServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    permissionsGET(providerName?: string | undefined, providerKey?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPermissionListResultDto> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGET(_response);
        });
    }

    protected processPermissionsGET(response: AxiosResponse): Promise<GetPermissionListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetPermissionListResultDto.fromJS(resultData200);
            return Promise.resolve<GetPermissionListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPermissionListResultDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    permissionsPUT(providerName?: string | undefined, providerKey?: string | undefined, body?: UpdatePermissionsDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsPUT(_response);
        });
    }

    protected processPermissionsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProfileServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    myProfileGET( cancelToken?: CancelToken | undefined): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/account/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMyProfileGET(_response);
        });
    }

    protected processMyProfileGET(response: AxiosResponse): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileDto.fromJS(resultData200);
            return Promise.resolve<ProfileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    myProfilePUT(body?: UpdateProfileDto | undefined, cancelToken?: CancelToken | undefined): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/account/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMyProfilePUT(_response);
        });
    }

    protected processMyProfilePUT(response: AxiosResponse): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileDto.fromJS(resultData200);
            return Promise.resolve<ProfileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body?: ChangePasswordInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/my-profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RoleServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    all( cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    rolesGET(filter?: string | undefined, sorting?: string | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined, cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET(_response);
        });
    }

    protected processRolesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPOST(body?: IdentityRoleCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPOST(_response);
        });
    }

    protected processRolesPOST(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET2(id: string, cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET2(_response);
        });
    }

    protected processRolesGET2(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT(id: string, body?: IdentityRoleUpdateDto | undefined, cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT(_response);
        });
    }

    protected processRolesPUT(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesDELETE(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesDELETE(_response);
        });
    }

    protected processRolesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TenantServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    tenantsGET(id: string, cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsGET(_response);
        });
    }

    protected processTenantsGET(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPUT(id: string, body?: TenantUpdateDto | undefined, cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsPUT(_response);
        });
    }

    protected processTenantsPUT(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @return Success
     */
    tenantsDELETE(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsDELETE(_response);
        });
    }

    protected processTenantsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    tenantsGET2(filter?: string | undefined, sorting?: string | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined, cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsGET2(_response);
        });
    }

    protected processTenantsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPOST(body?: TenantCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsPOST(_response);
        });
    }

    protected processTenantsPOST(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @return Success
     */
    defaultConnectionStringGET(id: string, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}/default-connection-string";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefaultConnectionStringGET(_response);
        });
    }

    protected processDefaultConnectionStringGET(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param defaultConnectionString (optional) 
     * @return Success
     */
    defaultConnectionStringPUT(id: string, defaultConnectionString?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}/default-connection-string?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (defaultConnectionString === null)
            throw new Error("The parameter 'defaultConnectionString' cannot be null.");
        else if (defaultConnectionString !== undefined)
            url_ += "defaultConnectionString=" + encodeURIComponent("" + defaultConnectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefaultConnectionStringPUT(_response);
        });
    }

    protected processDefaultConnectionStringPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    defaultConnectionStringDELETE(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}/default-connection-string";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefaultConnectionStringDELETE(_response);
        });
    }

    protected processDefaultConnectionStringDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    usersGET(id: string, cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: string, body?: IdentityUserUpdateDto | undefined, cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    usersGET2(filter?: string | undefined, sorting?: string | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined, cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersGET2(_response);
        });
    }

    protected processUsersGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body?: IdentityUserCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET3(id: string, cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET3(_response);
        });
    }

    protected processRolesGET3(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT2(id: string, body?: IdentityUserUpdateRolesDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT2(_response);
        });
    }

    protected processRolesPUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    assignableRoles( cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/assignable-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignableRoles(_response);
        });
    }

    protected processAssignableRoles(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    byUsername(userName: string, cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByUsername(_response);
        });
    }

    protected processByUsername(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    byEmail(email: string, cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByEmail(_response);
        });
    }

    protected processByEmail(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }
}

export class UserLookupServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    lookup(id: string, cancelToken?: CancelToken | undefined): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLookup(_response);
        });
    }

    protected processLookup(response: AxiosResponse): Promise<UserData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserData.fromJS(resultData200);
            return Promise.resolve<UserData>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(null as any);
    }

    /**
     * @return Success
     */
    byUsername2(userName: string, cancelToken?: CancelToken | undefined): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByUsername2(_response);
        });
    }

    protected processByUsername2(response: AxiosResponse): Promise<UserData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserData.fromJS(resultData200);
            return Promise.resolve<UserData>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    search(filter?: string | undefined, sorting?: string | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined, cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/search?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    count(filter?: string | undefined, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/count?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCount(_response);
        });
    }

    protected processCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword?: string | null;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"] !== undefined ? _data["currentPassword"] : <any>null;
            this.newPassword = _data["newPassword"] !== undefined ? _data["newPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword !== undefined ? this.currentPassword : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword?: string | null;
    newPassword: string;
}

export class ProfileDto implements IProfileDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    userName?: string | null;
    email?: string | null;
    name?: string | null;
    surname?: string | null;
    phoneNumber?: string | null;
    isExternal?: boolean;
    hasPassword?: boolean;
    concurrencyStamp?: string | null;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.isExternal = _data["isExternal"] !== undefined ? _data["isExternal"] : <any>null;
            this.hasPassword = _data["hasPassword"] !== undefined ? _data["hasPassword"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["isExternal"] = this.isExternal !== undefined ? this.isExternal : <any>null;
        data["hasPassword"] = this.hasPassword !== undefined ? this.hasPassword : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface IProfileDto {
    extraProperties?: { [key: string]: any; } | null;
    userName?: string | null;
    email?: string | null;
    name?: string | null;
    surname?: string | null;
    phoneNumber?: string | null;
    isExternal?: boolean;
    hasPassword?: boolean;
    concurrencyStamp?: string | null;
}

export class RegisterDto implements IRegisterDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    userName!: string;
    emailAddress!: string;
    password!: string;
    appName!: string;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.emailAddress = _data["emailAddress"] !== undefined ? _data["emailAddress"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        return data;
    }
}

export interface IRegisterDto {
    extraProperties?: { [key: string]: any; } | null;
    userName: string;
    emailAddress: string;
    password: string;
    appName: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    userId?: string;
    resetToken!: string;
    password!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.resetToken = _data["resetToken"] !== undefined ? _data["resetToken"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["resetToken"] = this.resetToken !== undefined ? this.resetToken : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IResetPasswordDto {
    userId?: string;
    resetToken: string;
    password: string;
}

export class SendPasswordResetCodeDto implements ISendPasswordResetCodeDto {
    email!: string;
    appName!: string;
    returnUrl?: string | null;
    returnUrlHash?: string | null;

    constructor(data?: ISendPasswordResetCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
            this.returnUrl = _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
            this.returnUrlHash = _data["returnUrlHash"] !== undefined ? _data["returnUrlHash"] : <any>null;
        }
    }

    static fromJS(data: any): SendPasswordResetCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        data["returnUrl"] = this.returnUrl !== undefined ? this.returnUrl : <any>null;
        data["returnUrlHash"] = this.returnUrlHash !== undefined ? this.returnUrlHash : <any>null;
        return data;
    }
}

export interface ISendPasswordResetCodeDto {
    email: string;
    appName: string;
    returnUrl?: string | null;
    returnUrlHash?: string | null;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    userName?: string | null;
    email?: string | null;
    name?: string | null;
    surname?: string | null;
    phoneNumber?: string | null;
    concurrencyStamp?: string | null;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface IUpdateProfileDto {
    extraProperties?: { [key: string]: any; } | null;
    userName?: string | null;
    email?: string | null;
    name?: string | null;
    surname?: string | null;
    phoneNumber?: string | null;
    concurrencyStamp?: string | null;
}

export class VerifyPasswordResetTokenInput implements IVerifyPasswordResetTokenInput {
    userId?: string;
    resetToken!: string;

    constructor(data?: IVerifyPasswordResetTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.resetToken = _data["resetToken"] !== undefined ? _data["resetToken"] : <any>null;
        }
    }

    static fromJS(data: any): VerifyPasswordResetTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyPasswordResetTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["resetToken"] = this.resetToken !== undefined ? this.resetToken : <any>null;
        return data;
    }
}

export interface IVerifyPasswordResetTokenInput {
    userId?: string;
    resetToken: string;
}

export class ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | null;

    constructor(data?: IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | null;
}

export class ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: UserData[] | null;

    constructor(data?: IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserData.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: UserData[] | null;
}

export class PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | null;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | null;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityUserDto[] | null;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityUserDto[] | null;
    totalCount?: number;
}

export class PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TenantDto[] | null;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data;
    }
}

export interface IPagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TenantDto[] | null;
    totalCount?: number;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    grantedPolicies?: { [key: string]: boolean; } | null;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key] !== undefined ? _data["grantedPolicies"][key] : <any>null;
                }
            }
            else {
                this.grantedPolicies = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = this.grantedPolicies[key] !== undefined ? this.grantedPolicies[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationAuthConfigurationDto {
    grantedPolicies?: { [key: string]: boolean; } | null;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization?: ApplicationLocalizationConfigurationDto;
    auth?: ApplicationAuthConfigurationDto;
    setting?: ApplicationSettingConfigurationDto;
    currentUser?: CurrentUserDto;
    features?: ApplicationFeatureConfigurationDto;
    globalFeatures?: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy?: MultiTenancyInfoDto;
    currentTenant?: CurrentTenantDto;
    timing?: TimingDto;
    clock?: ClockDto;
    objectExtensions?: ObjectExtensionsDto;
    extraProperties?: { [key: string]: any; } | null;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"]) : <any>null;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"]) : <any>null;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"]) : <any>null;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"]) : <any>null;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"]) : <any>null;
            this.globalFeatures = _data["globalFeatures"] ? ApplicationGlobalFeatureConfigurationDto.fromJS(_data["globalFeatures"]) : <any>null;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"]) : <any>null;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"]) : <any>null;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"]) : <any>null;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"]) : <any>null;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"]) : <any>null;
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                this.extraProperties = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>null;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>null;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>null;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>null;
        data["features"] = this.features ? this.features.toJSON() : <any>null;
        data["globalFeatures"] = this.globalFeatures ? this.globalFeatures.toJSON() : <any>null;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>null;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>null;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>null;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>null;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>null;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationConfigurationDto {
    localization?: ApplicationLocalizationConfigurationDto;
    auth?: ApplicationAuthConfigurationDto;
    setting?: ApplicationSettingConfigurationDto;
    currentUser?: CurrentUserDto;
    features?: ApplicationFeatureConfigurationDto;
    globalFeatures?: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy?: MultiTenancyInfoDto;
    currentTenant?: CurrentTenantDto;
    timing?: TimingDto;
    clock?: ClockDto;
    objectExtensions?: ObjectExtensionsDto;
    extraProperties?: { [key: string]: any; } | null;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values?: { [key: string]: string; } | null;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : <any>null;
                }
            }
            else {
                this.values = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] !== undefined ? this.values[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationFeatureConfigurationDto {
    values?: { [key: string]: string; } | null;
}

export class ApplicationGlobalFeatureConfigurationDto implements IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures?: string[] | null;

    constructor(data?: IApplicationGlobalFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledFeatures"])) {
                this.enabledFeatures = [] as any;
                for (let item of _data["enabledFeatures"])
                    this.enabledFeatures!.push(item);
            }
            else {
                this.enabledFeatures = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationGlobalFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationGlobalFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledFeatures)) {
            data["enabledFeatures"] = [];
            for (let item of this.enabledFeatures)
                data["enabledFeatures"].push(item);
        }
        return data;
    }
}

export interface IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures?: string[] | null;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values?: { [key: string]: { [key: string]: string; }; } | null;
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | null;
    languages?: LanguageInfo[] | null;
    currentCulture?: CurrentCultureDto;
    defaultResourceName?: string | null;
    languagesMap?: { [key: string]: NameValue[]; } | null;
    languageFilesMap?: { [key: string]: NameValue[]; } | null;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : <any>null;
                }
            }
            else {
                this.values = <any>null;
            }
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
            else {
                this.resources = <any>null;
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            else {
                this.languages = <any>null;
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"]) : <any>null;
            this.defaultResourceName = _data["defaultResourceName"] !== undefined ? _data["defaultResourceName"] : <any>null;
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i)) : <any>null;
                }
            }
            else {
                this.languagesMap = <any>null;
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i)) : <any>null;
                }
            }
            else {
                this.languageFilesMap = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] !== undefined ? this.values[key] : <any>null;
            }
        }
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>null;
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>null;
        data["defaultResourceName"] = this.defaultResourceName !== undefined ? this.defaultResourceName : <any>null;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = this.languagesMap[key] !== undefined ? this.languagesMap[key] : <any>null;
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = this.languageFilesMap[key] !== undefined ? this.languageFilesMap[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values?: { [key: string]: { [key: string]: string; }; } | null;
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | null;
    languages?: LanguageInfo[] | null;
    currentCulture?: CurrentCultureDto;
    defaultResourceName?: string | null;
    languagesMap?: { [key: string]: NameValue[]; } | null;
    languageFilesMap?: { [key: string]: NameValue[]; } | null;
}

export class ApplicationLocalizationDto implements IApplicationLocalizationDto {
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | null;

    constructor(data?: IApplicationLocalizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
            else {
                this.resources = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationDto {
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | null;
}

export class ApplicationLocalizationResourceDto implements IApplicationLocalizationResourceDto {
    texts?: { [key: string]: string; } | null;
    baseResources?: string[] | null;

    constructor(data?: IApplicationLocalizationResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["texts"]) {
                this.texts = {} as any;
                for (let key in _data["texts"]) {
                    if (_data["texts"].hasOwnProperty(key))
                        (<any>this.texts)![key] = _data["texts"][key] !== undefined ? _data["texts"][key] : <any>null;
                }
            }
            else {
                this.texts = <any>null;
            }
            if (Array.isArray(_data["baseResources"])) {
                this.baseResources = [] as any;
                for (let item of _data["baseResources"])
                    this.baseResources!.push(item);
            }
            else {
                this.baseResources = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.texts) {
            data["texts"] = {};
            for (let key in this.texts) {
                if (this.texts.hasOwnProperty(key))
                    (<any>data["texts"])[key] = this.texts[key] !== undefined ? this.texts[key] : <any>null;
            }
        }
        if (Array.isArray(this.baseResources)) {
            data["baseResources"] = [];
            for (let item of this.baseResources)
                data["baseResources"].push(item);
        }
        return data;
    }
}

export interface IApplicationLocalizationResourceDto {
    texts?: { [key: string]: string; } | null;
    baseResources?: string[] | null;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values?: { [key: string]: string; } | null;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : <any>null;
                }
            }
            else {
                this.values = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] !== undefined ? this.values[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationSettingConfigurationDto {
    values?: { [key: string]: string; } | null;
}

export class ClockDto implements IClockDto {
    kind?: string | null;

    constructor(data?: IClockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"] !== undefined ? _data["kind"] : <any>null;
        }
    }

    static fromJS(data: any): ClockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind !== undefined ? this.kind : <any>null;
        return data;
    }
}

export interface IClockDto {
    kind?: string | null;
}

export class CurrentCultureDto implements ICurrentCultureDto {
    displayName?: string | null;
    englishName?: string | null;
    threeLetterIsoLanguageName?: string | null;
    twoLetterIsoLanguageName?: string | null;
    isRightToLeft?: boolean;
    cultureName?: string | null;
    name?: string | null;
    nativeName?: string | null;
    dateTimeFormat?: DateTimeFormatDto;

    constructor(data?: ICurrentCultureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.englishName = _data["englishName"] !== undefined ? _data["englishName"] : <any>null;
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"] !== undefined ? _data["threeLetterIsoLanguageName"] : <any>null;
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"] !== undefined ? _data["twoLetterIsoLanguageName"] : <any>null;
            this.isRightToLeft = _data["isRightToLeft"] !== undefined ? _data["isRightToLeft"] : <any>null;
            this.cultureName = _data["cultureName"] !== undefined ? _data["cultureName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.nativeName = _data["nativeName"] !== undefined ? _data["nativeName"] : <any>null;
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"]) : <any>null;
        }
    }

    static fromJS(data: any): CurrentCultureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCultureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["englishName"] = this.englishName !== undefined ? this.englishName : <any>null;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName !== undefined ? this.threeLetterIsoLanguageName : <any>null;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName !== undefined ? this.twoLetterIsoLanguageName : <any>null;
        data["isRightToLeft"] = this.isRightToLeft !== undefined ? this.isRightToLeft : <any>null;
        data["cultureName"] = this.cultureName !== undefined ? this.cultureName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nativeName"] = this.nativeName !== undefined ? this.nativeName : <any>null;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>null;
        return data;
    }
}

export interface ICurrentCultureDto {
    displayName?: string | null;
    englishName?: string | null;
    threeLetterIsoLanguageName?: string | null;
    twoLetterIsoLanguageName?: string | null;
    isRightToLeft?: boolean;
    cultureName?: string | null;
    name?: string | null;
    nativeName?: string | null;
    dateTimeFormat?: DateTimeFormatDto;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated?: boolean;
    id?: string | null;
    tenantId?: string | null;
    impersonatorUserId?: string | null;
    impersonatorTenantId?: string | null;
    impersonatorUserName?: string | null;
    impersonatorTenantName?: string | null;
    userName?: string | null;
    name?: string | null;
    surName?: string | null;
    email?: string | null;
    emailVerified?: boolean;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean;
    roles?: string[] | null;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"] !== undefined ? _data["isAuthenticated"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.impersonatorUserId = _data["impersonatorUserId"] !== undefined ? _data["impersonatorUserId"] : <any>null;
            this.impersonatorTenantId = _data["impersonatorTenantId"] !== undefined ? _data["impersonatorTenantId"] : <any>null;
            this.impersonatorUserName = _data["impersonatorUserName"] !== undefined ? _data["impersonatorUserName"] : <any>null;
            this.impersonatorTenantName = _data["impersonatorTenantName"] !== undefined ? _data["impersonatorTenantName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surName = _data["surName"] !== undefined ? _data["surName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.emailVerified = _data["emailVerified"] !== undefined ? _data["emailVerified"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberVerified = _data["phoneNumberVerified"] !== undefined ? _data["phoneNumberVerified"] : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            else {
                this.roles = <any>null;
            }
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated !== undefined ? this.isAuthenticated : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["impersonatorUserId"] = this.impersonatorUserId !== undefined ? this.impersonatorUserId : <any>null;
        data["impersonatorTenantId"] = this.impersonatorTenantId !== undefined ? this.impersonatorTenantId : <any>null;
        data["impersonatorUserName"] = this.impersonatorUserName !== undefined ? this.impersonatorUserName : <any>null;
        data["impersonatorTenantName"] = this.impersonatorTenantName !== undefined ? this.impersonatorTenantName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surName"] = this.surName !== undefined ? this.surName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["emailVerified"] = this.emailVerified !== undefined ? this.emailVerified : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberVerified"] = this.phoneNumberVerified !== undefined ? this.phoneNumberVerified : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICurrentUserDto {
    isAuthenticated?: boolean;
    id?: string | null;
    tenantId?: string | null;
    impersonatorUserId?: string | null;
    impersonatorTenantId?: string | null;
    impersonatorUserName?: string | null;
    impersonatorTenantName?: string | null;
    userName?: string | null;
    name?: string | null;
    surName?: string | null;
    email?: string | null;
    emailVerified?: boolean;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean;
    roles?: string[] | null;
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
    calendarAlgorithmType?: string | null;
    dateTimeFormatLong?: string | null;
    shortDatePattern?: string | null;
    fullDateTimePattern?: string | null;
    dateSeparator?: string | null;
    shortTimePattern?: string | null;
    longTimePattern?: string | null;

    constructor(data?: IDateTimeFormatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"] !== undefined ? _data["calendarAlgorithmType"] : <any>null;
            this.dateTimeFormatLong = _data["dateTimeFormatLong"] !== undefined ? _data["dateTimeFormatLong"] : <any>null;
            this.shortDatePattern = _data["shortDatePattern"] !== undefined ? _data["shortDatePattern"] : <any>null;
            this.fullDateTimePattern = _data["fullDateTimePattern"] !== undefined ? _data["fullDateTimePattern"] : <any>null;
            this.dateSeparator = _data["dateSeparator"] !== undefined ? _data["dateSeparator"] : <any>null;
            this.shortTimePattern = _data["shortTimePattern"] !== undefined ? _data["shortTimePattern"] : <any>null;
            this.longTimePattern = _data["longTimePattern"] !== undefined ? _data["longTimePattern"] : <any>null;
        }
    }

    static fromJS(data: any): DateTimeFormatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType !== undefined ? this.calendarAlgorithmType : <any>null;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong !== undefined ? this.dateTimeFormatLong : <any>null;
        data["shortDatePattern"] = this.shortDatePattern !== undefined ? this.shortDatePattern : <any>null;
        data["fullDateTimePattern"] = this.fullDateTimePattern !== undefined ? this.fullDateTimePattern : <any>null;
        data["dateSeparator"] = this.dateSeparator !== undefined ? this.dateSeparator : <any>null;
        data["shortTimePattern"] = this.shortTimePattern !== undefined ? this.shortTimePattern : <any>null;
        data["longTimePattern"] = this.longTimePattern !== undefined ? this.longTimePattern : <any>null;
        return data;
    }
}

export interface IDateTimeFormatDto {
    calendarAlgorithmType?: string | null;
    dateTimeFormatLong?: string | null;
    shortDatePattern?: string | null;
    fullDateTimePattern?: string | null;
    dateSeparator?: string | null;
    shortTimePattern?: string | null;
    longTimePattern?: string | null;
}

export class IanaTimeZone implements IIanaTimeZone {
    timeZoneName?: string | null;

    constructor(data?: IIanaTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"] !== undefined ? _data["timeZoneName"] : <any>null;
        }
    }

    static fromJS(data: any): IanaTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new IanaTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName !== undefined ? this.timeZoneName : <any>null;
        return data;
    }
}

export interface IIanaTimeZone {
    timeZoneName?: string | null;
}

export class EntityExtensionDto implements IEntityExtensionDto {
    properties?: { [key: string]: ExtensionPropertyDto; } | null;
    configuration?: { [key: string]: any; } | null;

    constructor(data?: IEntityExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key]) : new ExtensionPropertyDto();
                }
            }
            else {
                this.properties = <any>null;
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key] !== undefined ? _data["configuration"][key] : <any>null;
                }
            }
            else {
                this.configuration = <any>null;
            }
        }
    }

    static fromJS(data: any): EntityExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>null;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key] !== undefined ? this.configuration[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IEntityExtensionDto {
    properties?: { [key: string]: ExtensionPropertyDto; } | null;
    configuration?: { [key: string]: any; } | null;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
    fields?: ExtensionEnumFieldDto[] | null;
    localizationResource?: string | null;

    constructor(data?: IExtensionEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
            }
            else {
                this.fields = <any>null;
            }
            this.localizationResource = _data["localizationResource"] !== undefined ? _data["localizationResource"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource !== undefined ? this.localizationResource : <any>null;
        return data;
    }
}

export interface IExtensionEnumDto {
    fields?: ExtensionEnumFieldDto[] | null;
    localizationResource?: string | null;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
    name?: string | null;
    value?: any | null;

    constructor(data?: IExtensionEnumFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionEnumFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IExtensionEnumFieldDto {
    name?: string | null;
    value?: any | null;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data;
    }
}

export interface IExtensionPropertyApiCreateDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
    onGet?: ExtensionPropertyApiGetDto;
    onCreate?: ExtensionPropertyApiCreateDto;
    onUpdate?: ExtensionPropertyApiUpdateDto;

    constructor(data?: IExtensionPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"]) : <any>null;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"]) : <any>null;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"]) : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>null;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>null;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>null;
        return data;
    }
}

export interface IExtensionPropertyApiDto {
    onGet?: ExtensionPropertyApiGetDto;
    onCreate?: ExtensionPropertyApiCreateDto;
    onUpdate?: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data;
    }
}

export interface IExtensionPropertyApiGetDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data;
    }
}

export interface IExtensionPropertyApiUpdateDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
    typeSimple?: string | null;
    config?: { [key: string]: any; } | null;

    constructor(data?: IExtensionPropertyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key] !== undefined ? _data["config"][key] : <any>null;
                }
            }
            else {
                this.config = <any>null;
            }
        }
    }

    static fromJS(data: any): ExtensionPropertyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = this.config[key] !== undefined ? this.config[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IExtensionPropertyAttributeDto {
    typeSimple?: string | null;
    config?: { [key: string]: any; } | null;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
    type?: string | null;
    typeSimple?: string | null;
    displayName?: LocalizableStringDto;
    api?: ExtensionPropertyApiDto;
    ui?: ExtensionPropertyUiDto;
    attributes?: ExtensionPropertyAttributeDto[] | null;
    configuration?: { [key: string]: any; } | null;
    defaultValue?: any | null;

    constructor(data?: IExtensionPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"]) : <any>null;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"]) : <any>null;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"]) : <any>null;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
            }
            else {
                this.attributes = <any>null;
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key] !== undefined ? _data["configuration"][key] : <any>null;
                }
            }
            else {
                this.configuration = <any>null;
            }
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>null;
        data["api"] = this.api ? this.api.toJSON() : <any>null;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>null;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key] !== undefined ? this.configuration[key] : <any>null;
            }
        }
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        return data;
    }
}

export interface IExtensionPropertyDto {
    type?: string | null;
    typeSimple?: string | null;
    displayName?: LocalizableStringDto;
    api?: ExtensionPropertyApiDto;
    ui?: ExtensionPropertyUiDto;
    attributes?: ExtensionPropertyAttributeDto[] | null;
    configuration?: { [key: string]: any; } | null;
    defaultValue?: any | null;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
    onTable?: ExtensionPropertyUiTableDto;
    onCreateForm?: ExtensionPropertyUiFormDto;
    onEditForm?: ExtensionPropertyUiFormDto;
    lookup?: ExtensionPropertyUiLookupDto;

    constructor(data?: IExtensionPropertyUiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"]) : <any>null;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"]) : <any>null;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"]) : <any>null;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"]) : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>null;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>null;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>null;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>null;
        return data;
    }
}

export interface IExtensionPropertyUiDto {
    onTable?: ExtensionPropertyUiTableDto;
    onCreateForm?: ExtensionPropertyUiFormDto;
    onEditForm?: ExtensionPropertyUiFormDto;
    lookup?: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
    isVisible?: boolean;

    constructor(data?: IExtensionPropertyUiFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"] !== undefined ? _data["isVisible"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible !== undefined ? this.isVisible : <any>null;
        return data;
    }
}

export interface IExtensionPropertyUiFormDto {
    isVisible?: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
    url?: string | null;
    resultListPropertyName?: string | null;
    displayPropertyName?: string | null;
    valuePropertyName?: string | null;
    filterParamName?: string | null;

    constructor(data?: IExtensionPropertyUiLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.resultListPropertyName = _data["resultListPropertyName"] !== undefined ? _data["resultListPropertyName"] : <any>null;
            this.displayPropertyName = _data["displayPropertyName"] !== undefined ? _data["displayPropertyName"] : <any>null;
            this.valuePropertyName = _data["valuePropertyName"] !== undefined ? _data["valuePropertyName"] : <any>null;
            this.filterParamName = _data["filterParamName"] !== undefined ? _data["filterParamName"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["resultListPropertyName"] = this.resultListPropertyName !== undefined ? this.resultListPropertyName : <any>null;
        data["displayPropertyName"] = this.displayPropertyName !== undefined ? this.displayPropertyName : <any>null;
        data["valuePropertyName"] = this.valuePropertyName !== undefined ? this.valuePropertyName : <any>null;
        data["filterParamName"] = this.filterParamName !== undefined ? this.filterParamName : <any>null;
        return data;
    }
}

export interface IExtensionPropertyUiLookupDto {
    url?: string | null;
    resultListPropertyName?: string | null;
    displayPropertyName?: string | null;
    valuePropertyName?: string | null;
    filterParamName?: string | null;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
    isVisible?: boolean;

    constructor(data?: IExtensionPropertyUiTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"] !== undefined ? _data["isVisible"] : <any>null;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible !== undefined ? this.isVisible : <any>null;
        return data;
    }
}

export interface IExtensionPropertyUiTableDto {
    isVisible?: boolean;
}

export class LocalizableStringDto implements ILocalizableStringDto {
    name?: string | null;
    resource?: string | null;

    constructor(data?: ILocalizableStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.resource = _data["resource"] !== undefined ? _data["resource"] : <any>null;
        }
    }

    static fromJS(data: any): LocalizableStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["resource"] = this.resource !== undefined ? this.resource : <any>null;
        return data;
    }
}

export interface ILocalizableStringDto {
    name?: string | null;
    resource?: string | null;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
    entities?: { [key: string]: EntityExtensionDto; } | null;
    configuration?: { [key: string]: any; } | null;

    constructor(data?: IModuleExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key]) : new EntityExtensionDto();
                }
            }
            else {
                this.entities = <any>null;
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key] !== undefined ? _data["configuration"][key] : <any>null;
                }
            }
            else {
                this.configuration = <any>null;
            }
        }
    }

    static fromJS(data: any): ModuleExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>null;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key] !== undefined ? this.configuration[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IModuleExtensionDto {
    entities?: { [key: string]: EntityExtensionDto; } | null;
    configuration?: { [key: string]: any; } | null;
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
    modules?: { [key: string]: ModuleExtensionDto; } | null;
    enums?: { [key: string]: ExtensionEnumDto; } | null;

    constructor(data?: IObjectExtensionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key]) : new ModuleExtensionDto();
                }
            }
            else {
                this.modules = <any>null;
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key]) : new ExtensionEnumDto();
                }
            }
            else {
                this.enums = <any>null;
            }
        }
    }

    static fromJS(data: any): ObjectExtensionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectExtensionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>null;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>null;
            }
        }
        return data;
    }
}

export interface IObjectExtensionsDto {
    modules?: { [key: string]: ModuleExtensionDto; } | null;
    enums?: { [key: string]: ExtensionEnumDto; } | null;
}

export class TimeZone implements ITimeZone {
    iana?: IanaTimeZone;
    windows?: WindowsTimeZone;

    constructor(data?: ITimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"]) : <any>null;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"]) : <any>null;
        }
    }

    static fromJS(data: any): TimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>null;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>null;
        return data;
    }
}

export interface ITimeZone {
    iana?: IanaTimeZone;
    windows?: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
    timeZone?: TimeZone;

    constructor(data?: ITimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"]) : <any>null;
        }
    }

    static fromJS(data: any): TimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>null;
        return data;
    }
}

export interface ITimingDto {
    timeZone?: TimeZone;
}

export class WindowsTimeZone implements IWindowsTimeZone {
    timeZoneId?: string | null;

    constructor(data?: IWindowsTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"] !== undefined ? _data["timeZoneId"] : <any>null;
        }
    }

    static fromJS(data: any): WindowsTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new WindowsTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId !== undefined ? this.timeZoneId : <any>null;
        return data;
    }
}

export interface IWindowsTimeZone {
    timeZoneId?: string | null;
}

export class CurrentTenantDto implements ICurrentTenantDto {
    id?: string | null;
    name?: string | null;
    isAvailable?: boolean;

    constructor(data?: ICurrentTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any): CurrentTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data;
    }
}

export interface ICurrentTenantDto {
    id?: string | null;
    name?: string | null;
    isAvailable?: boolean;
}

export class FindTenantResultDto implements IFindTenantResultDto {
    success?: boolean;
    tenantId?: string | null;
    name?: string | null;
    isActive?: boolean;

    constructor(data?: IFindTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static fromJS(data: any): FindTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        return data;
    }
}

export interface IFindTenantResultDto {
    success?: boolean;
    tenantId?: string | null;
    name?: string | null;
    isActive?: boolean;
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
    isEnabled?: boolean;

    constructor(data?: IMultiTenancyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : <any>null;
        }
    }

    static fromJS(data: any): MultiTenancyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : <any>null;
        return data;
    }
}

export interface IMultiTenancyInfoDto {
    isEnabled?: boolean;
}

export class FeatureDto implements IFeatureDto {
    name?: string | null;
    displayName?: string | null;
    value?: string | null;
    provider?: FeatureProviderDto;
    description?: string | null;
    valueType?: IStringValueType;
    depth?: number;
    parentName?: string | null;

    constructor(data?: IFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.provider = _data["provider"] ? FeatureProviderDto.fromJS(_data["provider"]) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.valueType = _data["valueType"] ? IStringValueType.fromJS(_data["valueType"]) : <any>null;
            this.depth = _data["depth"] !== undefined ? _data["depth"] : <any>null;
            this.parentName = _data["parentName"] !== undefined ? _data["parentName"] : <any>null;
        }
    }

    static fromJS(data: any): FeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["valueType"] = this.valueType ? this.valueType.toJSON() : <any>null;
        data["depth"] = this.depth !== undefined ? this.depth : <any>null;
        data["parentName"] = this.parentName !== undefined ? this.parentName : <any>null;
        return data;
    }
}

export interface IFeatureDto {
    name?: string | null;
    displayName?: string | null;
    value?: string | null;
    provider?: FeatureProviderDto;
    description?: string | null;
    valueType?: IStringValueType;
    depth?: number;
    parentName?: string | null;
}

export class FeatureGroupDto implements IFeatureGroupDto {
    name?: string | null;
    displayName?: string | null;
    features?: FeatureDto[] | null;

    constructor(data?: IFeatureGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureDto.fromJS(item));
            }
            else {
                this.features = <any>null;
            }
        }
    }

    static fromJS(data: any): FeatureGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFeatureGroupDto {
    name?: string | null;
    displayName?: string | null;
    features?: FeatureDto[] | null;
}

export class FeatureProviderDto implements IFeatureProviderDto {
    name?: string | null;
    key?: string | null;

    constructor(data?: IFeatureProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
        }
    }

    static fromJS(data: any): FeatureProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        return data;
    }
}

export interface IFeatureProviderDto {
    name?: string | null;
    key?: string | null;
}

export class GetFeatureListResultDto implements IGetFeatureListResultDto {
    groups?: FeatureGroupDto[] | null;

    constructor(data?: IGetFeatureListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(FeatureGroupDto.fromJS(item));
            }
            else {
                this.groups = <any>null;
            }
        }
    }

    static fromJS(data: any): GetFeatureListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFeatureListResultDto {
    groups?: FeatureGroupDto[] | null;
}

export class UpdateFeatureDto implements IUpdateFeatureDto {
    name?: string | null;
    value?: string | null;

    constructor(data?: IUpdateFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IUpdateFeatureDto {
    name?: string | null;
    value?: string | null;
}

export class UpdateFeaturesDto implements IUpdateFeaturesDto {
    features?: UpdateFeatureDto[] | null;

    constructor(data?: IUpdateFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(UpdateFeatureDto.fromJS(item));
            }
            else {
                this.features = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdateFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateFeaturesDto {
    features?: UpdateFeatureDto[] | null;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName?: string | null;
    name?: string | null;
    httpMethod?: string | null;
    url?: string | null;
    supportedVersions?: string[] | null;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | null;
    parameters?: ParameterApiDescriptionModel[] | null;
    returnValue?: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean | null;
    implementFrom?: string | null;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"] !== undefined ? _data["uniqueName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.httpMethod = _data["httpMethod"] !== undefined ? _data["httpMethod"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            else {
                this.supportedVersions = <any>null;
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            else {
                this.parametersOnMethod = <any>null;
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            else {
                this.parameters = <any>null;
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>null;
            this.allowAnonymous = _data["allowAnonymous"] !== undefined ? _data["allowAnonymous"] : <any>null;
            this.implementFrom = _data["implementFrom"] !== undefined ? _data["implementFrom"] : <any>null;
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName !== undefined ? this.uniqueName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["httpMethod"] = this.httpMethod !== undefined ? this.httpMethod : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>null;
        data["allowAnonymous"] = this.allowAnonymous !== undefined ? this.allowAnonymous : <any>null;
        data["implementFrom"] = this.implementFrom !== undefined ? this.implementFrom : <any>null;
        return data;
    }
}

export interface IActionApiDescriptionModel {
    uniqueName?: string | null;
    name?: string | null;
    httpMethod?: string | null;
    url?: string | null;
    supportedVersions?: string[] | null;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | null;
    parameters?: ParameterApiDescriptionModel[] | null;
    returnValue?: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean | null;
    implementFrom?: string | null;
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules?: { [key: string]: ModuleApiDescriptionModel; } | null;
    types?: { [key: string]: TypeApiDescriptionModel; } | null;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
            else {
                this.modules = <any>null;
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key]) : new TypeApiDescriptionModel();
                }
            }
            else {
                this.types = <any>null;
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>null;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>null;
            }
        }
        return data;
    }
}

export interface IApplicationApiDescriptionModel {
    modules?: { [key: string]: ModuleApiDescriptionModel; } | null;
    types?: { [key: string]: TypeApiDescriptionModel; } | null;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName?: string | null;
    controllerGroupName?: string | null;
    isRemoteService?: boolean;
    isIntegrationService?: boolean;
    apiVersion?: string | null;
    type?: string | null;
    interfaces?: ControllerInterfaceApiDescriptionModel[] | null;
    actions?: { [key: string]: ActionApiDescriptionModel; } | null;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"] !== undefined ? _data["controllerName"] : <any>null;
            this.controllerGroupName = _data["controllerGroupName"] !== undefined ? _data["controllerGroupName"] : <any>null;
            this.isRemoteService = _data["isRemoteService"] !== undefined ? _data["isRemoteService"] : <any>null;
            this.isIntegrationService = _data["isIntegrationService"] !== undefined ? _data["isIntegrationService"] : <any>null;
            this.apiVersion = _data["apiVersion"] !== undefined ? _data["apiVersion"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            else {
                this.interfaces = <any>null;
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
            else {
                this.actions = <any>null;
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName !== undefined ? this.controllerName : <any>null;
        data["controllerGroupName"] = this.controllerGroupName !== undefined ? this.controllerGroupName : <any>null;
        data["isRemoteService"] = this.isRemoteService !== undefined ? this.isRemoteService : <any>null;
        data["isIntegrationService"] = this.isIntegrationService !== undefined ? this.isIntegrationService : <any>null;
        data["apiVersion"] = this.apiVersion !== undefined ? this.apiVersion : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>null;
            }
        }
        return data;
    }
}

export interface IControllerApiDescriptionModel {
    controllerName?: string | null;
    controllerGroupName?: string | null;
    isRemoteService?: boolean;
    isIntegrationService?: boolean;
    apiVersion?: string | null;
    type?: string | null;
    interfaces?: ControllerInterfaceApiDescriptionModel[] | null;
    actions?: { [key: string]: ActionApiDescriptionModel; } | null;
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    type?: string | null;
    name?: string | null;
    methods?: InterfaceMethodApiDescriptionModel[] | null;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["methods"])) {
                this.methods = [] as any;
                for (let item of _data["methods"])
                    this.methods!.push(InterfaceMethodApiDescriptionModel.fromJS(item));
            }
            else {
                this.methods = <any>null;
            }
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.methods)) {
            data["methods"] = [];
            for (let item of this.methods)
                data["methods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    type?: string | null;
    name?: string | null;
    methods?: InterfaceMethodApiDescriptionModel[] | null;
}

export class InterfaceMethodApiDescriptionModel implements IInterfaceMethodApiDescriptionModel {
    name?: string | null;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | null;
    returnValue?: ReturnValueApiDescriptionModel;

    constructor(data?: IInterfaceMethodApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            else {
                this.parametersOnMethod = <any>null;
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>null;
        }
    }

    static fromJS(data: any): InterfaceMethodApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new InterfaceMethodApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>null;
        return data;
    }
}

export interface IInterfaceMethodApiDescriptionModel {
    name?: string | null;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | null;
    returnValue?: ReturnValueApiDescriptionModel;
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name?: string | null;
    typeAsString?: string | null;
    type?: string | null;
    typeSimple?: string | null;
    isOptional?: boolean;
    defaultValue?: any | null;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.typeAsString = _data["typeAsString"] !== undefined ? _data["typeAsString"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.isOptional = _data["isOptional"] !== undefined ? _data["isOptional"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["typeAsString"] = this.typeAsString !== undefined ? this.typeAsString : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["isOptional"] = this.isOptional !== undefined ? this.isOptional : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        return data;
    }
}

export interface IMethodParameterApiDescriptionModel {
    name?: string | null;
    typeAsString?: string | null;
    type?: string | null;
    typeSimple?: string | null;
    isOptional?: boolean;
    defaultValue?: any | null;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath?: string | null;
    remoteServiceName?: string | null;
    controllers?: { [key: string]: ControllerApiDescriptionModel; } | null;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"] !== undefined ? _data["rootPath"] : <any>null;
            this.remoteServiceName = _data["remoteServiceName"] !== undefined ? _data["remoteServiceName"] : <any>null;
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
            else {
                this.controllers = <any>null;
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath !== undefined ? this.rootPath : <any>null;
        data["remoteServiceName"] = this.remoteServiceName !== undefined ? this.remoteServiceName : <any>null;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>null;
            }
        }
        return data;
    }
}

export interface IModuleApiDescriptionModel {
    rootPath?: string | null;
    remoteServiceName?: string | null;
    controllers?: { [key: string]: ControllerApiDescriptionModel; } | null;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod?: string | null;
    name?: string | null;
    jsonName?: string | null;
    type?: string | null;
    typeSimple?: string | null;
    isOptional?: boolean;
    defaultValue?: any | null;
    constraintTypes?: string[] | null;
    bindingSourceId?: string | null;
    descriptorName?: string | null;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"] !== undefined ? _data["nameOnMethod"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.jsonName = _data["jsonName"] !== undefined ? _data["jsonName"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.isOptional = _data["isOptional"] !== undefined ? _data["isOptional"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            else {
                this.constraintTypes = <any>null;
            }
            this.bindingSourceId = _data["bindingSourceId"] !== undefined ? _data["bindingSourceId"] : <any>null;
            this.descriptorName = _data["descriptorName"] !== undefined ? _data["descriptorName"] : <any>null;
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod !== undefined ? this.nameOnMethod : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["jsonName"] = this.jsonName !== undefined ? this.jsonName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["isOptional"] = this.isOptional !== undefined ? this.isOptional : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId !== undefined ? this.bindingSourceId : <any>null;
        data["descriptorName"] = this.descriptorName !== undefined ? this.descriptorName : <any>null;
        return data;
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod?: string | null;
    name?: string | null;
    jsonName?: string | null;
    type?: string | null;
    typeSimple?: string | null;
    isOptional?: boolean;
    defaultValue?: any | null;
    constraintTypes?: string[] | null;
    bindingSourceId?: string | null;
    descriptorName?: string | null;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
    name?: string | null;
    jsonName?: string | null;
    type?: string | null;
    typeSimple?: string | null;
    isRequired?: boolean;
    minLength?: number | null;
    maxLength?: number | null;
    minimum?: string | null;
    maximum?: string | null;
    regex?: string | null;

    constructor(data?: IPropertyApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.jsonName = _data["jsonName"] !== undefined ? _data["jsonName"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.isRequired = _data["isRequired"] !== undefined ? _data["isRequired"] : <any>null;
            this.minLength = _data["minLength"] !== undefined ? _data["minLength"] : <any>null;
            this.maxLength = _data["maxLength"] !== undefined ? _data["maxLength"] : <any>null;
            this.minimum = _data["minimum"] !== undefined ? _data["minimum"] : <any>null;
            this.maximum = _data["maximum"] !== undefined ? _data["maximum"] : <any>null;
            this.regex = _data["regex"] !== undefined ? _data["regex"] : <any>null;
        }
    }

    static fromJS(data: any): PropertyApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["jsonName"] = this.jsonName !== undefined ? this.jsonName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["isRequired"] = this.isRequired !== undefined ? this.isRequired : <any>null;
        data["minLength"] = this.minLength !== undefined ? this.minLength : <any>null;
        data["maxLength"] = this.maxLength !== undefined ? this.maxLength : <any>null;
        data["minimum"] = this.minimum !== undefined ? this.minimum : <any>null;
        data["maximum"] = this.maximum !== undefined ? this.maximum : <any>null;
        data["regex"] = this.regex !== undefined ? this.regex : <any>null;
        return data;
    }
}

export interface IPropertyApiDescriptionModel {
    name?: string | null;
    jsonName?: string | null;
    type?: string | null;
    typeSimple?: string | null;
    isRequired?: boolean;
    minLength?: number | null;
    maxLength?: number | null;
    minimum?: string | null;
    maximum?: string | null;
    regex?: string | null;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    type?: string | null;
    typeSimple?: string | null;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        return data;
    }
}

export interface IReturnValueApiDescriptionModel {
    type?: string | null;
    typeSimple?: string | null;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
    baseType?: string | null;
    isEnum?: boolean;
    enumNames?: string[] | null;
    enumValues?: any[] | null;
    genericArguments?: string[] | null;
    properties?: PropertyApiDescriptionModel[] | null;

    constructor(data?: ITypeApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseType = _data["baseType"] !== undefined ? _data["baseType"] : <any>null;
            this.isEnum = _data["isEnum"] !== undefined ? _data["isEnum"] : <any>null;
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            else {
                this.enumNames = <any>null;
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            else {
                this.enumValues = <any>null;
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            else {
                this.genericArguments = <any>null;
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
            }
            else {
                this.properties = <any>null;
            }
        }
    }

    static fromJS(data: any): TypeApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TypeApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType !== undefined ? this.baseType : <any>null;
        data["isEnum"] = this.isEnum !== undefined ? this.isEnum : <any>null;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeApiDescriptionModel {
    baseType?: string | null;
    isEnum?: boolean;
    enumNames?: string[] | null;
    enumValues?: any[] | null;
    genericArguments?: string[] | null;
    properties?: PropertyApiDescriptionModel[] | null;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
    code?: string | null;
    message?: string | null;
    details?: string | null;
    data?: { [key: string]: any; } | null;
    validationErrors?: RemoteServiceValidationErrorInfo[] | null;

    constructor(data?: IRemoteServiceErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key] !== undefined ? _data["data"][key] : <any>null;
                }
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
            }
            else {
                this.validationErrors = <any>null;
            }
        }
    }

    static fromJS(data: any): RemoteServiceErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = this.data[key] !== undefined ? this.data[key] : <any>null;
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteServiceErrorInfo {
    code?: string | null;
    message?: string | null;
    details?: string | null;
    data?: { [key: string]: any; } | null;
    validationErrors?: RemoteServiceValidationErrorInfo[] | null;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
    error?: RemoteServiceErrorInfo;

    constructor(data?: IRemoteServiceErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"]) : <any>null;
        }
    }

    static fromJS(data: any): RemoteServiceErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>null;
        return data;
    }
}

export interface IRemoteServiceErrorResponse {
    error?: RemoteServiceErrorInfo;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
    message?: string | null;
    members?: string[] | null;

    constructor(data?: IRemoteServiceValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
            else {
                this.members = <any>null;
            }
        }
    }

    static fromJS(data: any): RemoteServiceValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data;
    }
}

export interface IRemoteServiceValidationErrorInfo {
    message?: string | null;
    members?: string[] | null;
}

export class IdentityRoleCreateDto implements IIdentityRoleCreateDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;

    constructor(data?: IIdentityRoleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
        }
    }

    static fromJS(data: any): IdentityRoleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        return data;
    }
}

export interface IIdentityRoleCreateDto {
    extraProperties?: { [key: string]: any; } | null;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
}

export class IdentityRoleDto implements IIdentityRoleDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    id?: string;
    name?: string | null;
    isDefault?: boolean;
    isStatic?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | null;

    constructor(data?: IIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isStatic = _data["isStatic"] !== undefined ? _data["isStatic"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isStatic"] = this.isStatic !== undefined ? this.isStatic : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface IIdentityRoleDto {
    extraProperties?: { [key: string]: any; } | null;
    id?: string;
    name?: string | null;
    isDefault?: boolean;
    isStatic?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | null;
}

export class IdentityRoleUpdateDto implements IIdentityRoleUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | null;

    constructor(data?: IIdentityRoleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): IdentityRoleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface IIdentityRoleUpdateDto {
    extraProperties?: { [key: string]: any; } | null;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | null;
}

export class IdentityUserCreateDto implements IIdentityUserCreateDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    userName!: string;
    name?: string | null;
    surname?: string | null;
    email!: string;
    phoneNumber?: string | null;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | null;
    password!: string;

    constructor(data?: IIdentityUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            else {
                this.roleNames = <any>null;
            }
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): IdentityUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IIdentityUserCreateDto {
    extraProperties?: { [key: string]: any; } | null;
    userName: string;
    name?: string | null;
    surname?: string | null;
    email: string;
    phoneNumber?: string | null;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | null;
    password: string;
}

export class IdentityUserDto implements IIdentityUserDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    id?: string;
    creationTime?: Date;
    creatorId?: string | null;
    lastModificationTime?: Date | null;
    lastModifierId?: string | null;
    isDeleted?: boolean;
    deleterId?: string | null;
    deletionTime?: Date | null;
    tenantId?: string | null;
    userName?: string | null;
    name?: string | null;
    surname?: string | null;
    email?: string | null;
    emailConfirmed?: boolean;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    lockoutEnd?: Date | null;
    concurrencyStamp?: string | null;
    entityVersion?: number;

    constructor(data?: IIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>null;
            this.creatorId = _data["creatorId"] !== undefined ? _data["creatorId"] : <any>null;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>null;
            this.lastModifierId = _data["lastModifierId"] !== undefined ? _data["lastModifierId"] : <any>null;
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : <any>null;
            this.deleterId = _data["deleterId"] !== undefined ? _data["deleterId"] : <any>null;
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
            this.entityVersion = _data["entityVersion"] !== undefined ? _data["entityVersion"] : <any>null;
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>null;
        data["creatorId"] = this.creatorId !== undefined ? this.creatorId : <any>null;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>null;
        data["lastModifierId"] = this.lastModifierId !== undefined ? this.lastModifierId : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["deleterId"] = this.deleterId !== undefined ? this.deleterId : <any>null;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        data["entityVersion"] = this.entityVersion !== undefined ? this.entityVersion : <any>null;
        return data;
    }
}

export interface IIdentityUserDto {
    extraProperties?: { [key: string]: any; } | null;
    id?: string;
    creationTime?: Date;
    creatorId?: string | null;
    lastModificationTime?: Date | null;
    lastModifierId?: string | null;
    isDeleted?: boolean;
    deleterId?: string | null;
    deletionTime?: Date | null;
    tenantId?: string | null;
    userName?: string | null;
    name?: string | null;
    surname?: string | null;
    email?: string | null;
    emailConfirmed?: boolean;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    lockoutEnd?: Date | null;
    concurrencyStamp?: string | null;
    entityVersion?: number;
}

export class IdentityUserUpdateDto implements IIdentityUserUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    userName!: string;
    name?: string | null;
    surname?: string | null;
    email!: string;
    phoneNumber?: string | null;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | null;
    password?: string | null;
    concurrencyStamp?: string | null;

    constructor(data?: IIdentityUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            else {
                this.roleNames = <any>null;
            }
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): IdentityUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface IIdentityUserUpdateDto {
    extraProperties?: { [key: string]: any; } | null;
    userName: string;
    name?: string | null;
    surname?: string | null;
    email: string;
    phoneNumber?: string | null;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | null;
    password?: string | null;
    concurrencyStamp?: string | null;
}

export class IdentityUserUpdateRolesDto implements IIdentityUserUpdateRolesDto {
    roleNames!: string[];

    constructor(data?: IIdentityUserUpdateRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            else {
                this.roleNames = <any>null;
            }
        }
    }

    static fromJS(data: any): IdentityUserUpdateRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }
}

export interface IIdentityUserUpdateRolesDto {
    roleNames: string[];
}

export class LanguageInfo implements ILanguageInfo {
    cultureName?: string | null;
    uiCultureName?: string | null;
    displayName?: string | null;
    readonly twoLetterISOLanguageName?: string | null;
    flagIcon?: string | null;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cultureName = _data["cultureName"] !== undefined ? _data["cultureName"] : <any>null;
            this.uiCultureName = _data["uiCultureName"] !== undefined ? _data["uiCultureName"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"] !== undefined ? _data["twoLetterISOLanguageName"] : <any>null;
            this.flagIcon = _data["flagIcon"] !== undefined ? _data["flagIcon"] : <any>null;
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName !== undefined ? this.cultureName : <any>null;
        data["uiCultureName"] = this.uiCultureName !== undefined ? this.uiCultureName : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName !== undefined ? this.twoLetterISOLanguageName : <any>null;
        data["flagIcon"] = this.flagIcon !== undefined ? this.flagIcon : <any>null;
        return data;
    }
}

export interface ILanguageInfo {
    cultureName?: string | null;
    uiCultureName?: string | null;
    displayName?: string | null;
    twoLetterISOLanguageName?: string | null;
    flagIcon?: string | null;
}

export class NameValue implements INameValue {
    name?: string | null;
    value?: string | null;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface INameValue {
    name?: string | null;
    value?: string | null;
}

export class GetPermissionListResultDto implements IGetPermissionListResultDto {
    entityDisplayName?: string | null;
    groups?: PermissionGroupDto[] | null;

    constructor(data?: IGetPermissionListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDisplayName = _data["entityDisplayName"] !== undefined ? _data["entityDisplayName"] : <any>null;
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(PermissionGroupDto.fromJS(item));
            }
            else {
                this.groups = <any>null;
            }
        }
    }

    static fromJS(data: any): GetPermissionListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDisplayName"] = this.entityDisplayName !== undefined ? this.entityDisplayName : <any>null;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPermissionListResultDto {
    entityDisplayName?: string | null;
    groups?: PermissionGroupDto[] | null;
}

export class PermissionGrantInfoDto implements IPermissionGrantInfoDto {
    name?: string | null;
    displayName?: string | null;
    parentName?: string | null;
    isGranted?: boolean;
    allowedProviders?: string[] | null;
    grantedProviders?: ProviderInfoDto[] | null;

    constructor(data?: IPermissionGrantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.parentName = _data["parentName"] !== undefined ? _data["parentName"] : <any>null;
            this.isGranted = _data["isGranted"] !== undefined ? _data["isGranted"] : <any>null;
            if (Array.isArray(_data["allowedProviders"])) {
                this.allowedProviders = [] as any;
                for (let item of _data["allowedProviders"])
                    this.allowedProviders!.push(item);
            }
            else {
                this.allowedProviders = <any>null;
            }
            if (Array.isArray(_data["grantedProviders"])) {
                this.grantedProviders = [] as any;
                for (let item of _data["grantedProviders"])
                    this.grantedProviders!.push(ProviderInfoDto.fromJS(item));
            }
            else {
                this.grantedProviders = <any>null;
            }
        }
    }

    static fromJS(data: any): PermissionGrantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["parentName"] = this.parentName !== undefined ? this.parentName : <any>null;
        data["isGranted"] = this.isGranted !== undefined ? this.isGranted : <any>null;
        if (Array.isArray(this.allowedProviders)) {
            data["allowedProviders"] = [];
            for (let item of this.allowedProviders)
                data["allowedProviders"].push(item);
        }
        if (Array.isArray(this.grantedProviders)) {
            data["grantedProviders"] = [];
            for (let item of this.grantedProviders)
                data["grantedProviders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGrantInfoDto {
    name?: string | null;
    displayName?: string | null;
    parentName?: string | null;
    isGranted?: boolean;
    allowedProviders?: string[] | null;
    grantedProviders?: ProviderInfoDto[] | null;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    name?: string | null;
    displayName?: string | null;
    displayNameKey?: string | null;
    displayNameResource?: string | null;
    permissions?: PermissionGrantInfoDto[] | null;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.displayNameKey = _data["displayNameKey"] !== undefined ? _data["displayNameKey"] : <any>null;
            this.displayNameResource = _data["displayNameResource"] !== undefined ? _data["displayNameResource"] : <any>null;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantInfoDto.fromJS(item));
            }
            else {
                this.permissions = <any>null;
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["displayNameKey"] = this.displayNameKey !== undefined ? this.displayNameKey : <any>null;
        data["displayNameResource"] = this.displayNameResource !== undefined ? this.displayNameResource : <any>null;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGroupDto {
    name?: string | null;
    displayName?: string | null;
    displayNameKey?: string | null;
    displayNameResource?: string | null;
    permissions?: PermissionGrantInfoDto[] | null;
}

export class ProviderInfoDto implements IProviderInfoDto {
    providerName?: string | null;
    providerKey?: string | null;

    constructor(data?: IProviderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"] !== undefined ? _data["providerName"] : <any>null;
            this.providerKey = _data["providerKey"] !== undefined ? _data["providerKey"] : <any>null;
        }
    }

    static fromJS(data: any): ProviderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName !== undefined ? this.providerName : <any>null;
        data["providerKey"] = this.providerKey !== undefined ? this.providerKey : <any>null;
        return data;
    }
}

export interface IProviderInfoDto {
    providerName?: string | null;
    providerKey?: string | null;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    name?: string | null;
    isGranted?: boolean;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isGranted = _data["isGranted"] !== undefined ? _data["isGranted"] : <any>null;
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isGranted"] = this.isGranted !== undefined ? this.isGranted : <any>null;
        return data;
    }
}

export interface IUpdatePermissionDto {
    name?: string | null;
    isGranted?: boolean;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
    permissions?: UpdatePermissionDto[] | null;

    constructor(data?: IUpdatePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item));
            }
            else {
                this.permissions = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdatePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePermissionsDto {
    permissions?: UpdatePermissionDto[] | null;
}

export class EmailSettingsDto implements IEmailSettingsDto {
    smtpHost?: string | null;
    smtpPort?: number;
    smtpUserName?: string | null;
    smtpPassword?: string | null;
    smtpDomain?: string | null;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress?: string | null;
    defaultFromDisplayName?: string | null;

    constructor(data?: IEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"] !== undefined ? _data["smtpHost"] : <any>null;
            this.smtpPort = _data["smtpPort"] !== undefined ? _data["smtpPort"] : <any>null;
            this.smtpUserName = _data["smtpUserName"] !== undefined ? _data["smtpUserName"] : <any>null;
            this.smtpPassword = _data["smtpPassword"] !== undefined ? _data["smtpPassword"] : <any>null;
            this.smtpDomain = _data["smtpDomain"] !== undefined ? _data["smtpDomain"] : <any>null;
            this.smtpEnableSsl = _data["smtpEnableSsl"] !== undefined ? _data["smtpEnableSsl"] : <any>null;
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"] !== undefined ? _data["smtpUseDefaultCredentials"] : <any>null;
            this.defaultFromAddress = _data["defaultFromAddress"] !== undefined ? _data["defaultFromAddress"] : <any>null;
            this.defaultFromDisplayName = _data["defaultFromDisplayName"] !== undefined ? _data["defaultFromDisplayName"] : <any>null;
        }
    }

    static fromJS(data: any): EmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost !== undefined ? this.smtpHost : <any>null;
        data["smtpPort"] = this.smtpPort !== undefined ? this.smtpPort : <any>null;
        data["smtpUserName"] = this.smtpUserName !== undefined ? this.smtpUserName : <any>null;
        data["smtpPassword"] = this.smtpPassword !== undefined ? this.smtpPassword : <any>null;
        data["smtpDomain"] = this.smtpDomain !== undefined ? this.smtpDomain : <any>null;
        data["smtpEnableSsl"] = this.smtpEnableSsl !== undefined ? this.smtpEnableSsl : <any>null;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials !== undefined ? this.smtpUseDefaultCredentials : <any>null;
        data["defaultFromAddress"] = this.defaultFromAddress !== undefined ? this.defaultFromAddress : <any>null;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName !== undefined ? this.defaultFromDisplayName : <any>null;
        return data;
    }
}

export interface IEmailSettingsDto {
    smtpHost?: string | null;
    smtpPort?: number;
    smtpUserName?: string | null;
    smtpPassword?: string | null;
    smtpDomain?: string | null;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress?: string | null;
    defaultFromDisplayName?: string | null;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    senderEmailAddress!: string;
    targetEmailAddress!: string;
    subject!: string;
    body?: string | null;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderEmailAddress = _data["senderEmailAddress"] !== undefined ? _data["senderEmailAddress"] : <any>null;
            this.targetEmailAddress = _data["targetEmailAddress"] !== undefined ? _data["targetEmailAddress"] : <any>null;
            this.subject = _data["subject"] !== undefined ? _data["subject"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderEmailAddress"] = this.senderEmailAddress !== undefined ? this.senderEmailAddress : <any>null;
        data["targetEmailAddress"] = this.targetEmailAddress !== undefined ? this.targetEmailAddress : <any>null;
        data["subject"] = this.subject !== undefined ? this.subject : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface ISendTestEmailInput {
    senderEmailAddress: string;
    targetEmailAddress: string;
    subject: string;
    body?: string | null;
}

export class UpdateEmailSettingsDto implements IUpdateEmailSettingsDto {
    smtpHost?: string | null;
    smtpPort?: number;
    smtpUserName?: string | null;
    smtpPassword?: string | null;
    smtpDomain?: string | null;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress!: string;
    defaultFromDisplayName!: string;

    constructor(data?: IUpdateEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"] !== undefined ? _data["smtpHost"] : <any>null;
            this.smtpPort = _data["smtpPort"] !== undefined ? _data["smtpPort"] : <any>null;
            this.smtpUserName = _data["smtpUserName"] !== undefined ? _data["smtpUserName"] : <any>null;
            this.smtpPassword = _data["smtpPassword"] !== undefined ? _data["smtpPassword"] : <any>null;
            this.smtpDomain = _data["smtpDomain"] !== undefined ? _data["smtpDomain"] : <any>null;
            this.smtpEnableSsl = _data["smtpEnableSsl"] !== undefined ? _data["smtpEnableSsl"] : <any>null;
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"] !== undefined ? _data["smtpUseDefaultCredentials"] : <any>null;
            this.defaultFromAddress = _data["defaultFromAddress"] !== undefined ? _data["defaultFromAddress"] : <any>null;
            this.defaultFromDisplayName = _data["defaultFromDisplayName"] !== undefined ? _data["defaultFromDisplayName"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateEmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost !== undefined ? this.smtpHost : <any>null;
        data["smtpPort"] = this.smtpPort !== undefined ? this.smtpPort : <any>null;
        data["smtpUserName"] = this.smtpUserName !== undefined ? this.smtpUserName : <any>null;
        data["smtpPassword"] = this.smtpPassword !== undefined ? this.smtpPassword : <any>null;
        data["smtpDomain"] = this.smtpDomain !== undefined ? this.smtpDomain : <any>null;
        data["smtpEnableSsl"] = this.smtpEnableSsl !== undefined ? this.smtpEnableSsl : <any>null;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials !== undefined ? this.smtpUseDefaultCredentials : <any>null;
        data["defaultFromAddress"] = this.defaultFromAddress !== undefined ? this.defaultFromAddress : <any>null;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName !== undefined ? this.defaultFromDisplayName : <any>null;
        return data;
    }
}

export interface IUpdateEmailSettingsDto {
    smtpHost?: string | null;
    smtpPort?: number;
    smtpUserName?: string | null;
    smtpPassword?: string | null;
    smtpDomain?: string | null;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress: string;
    defaultFromDisplayName: string;
}

export class TenantCreateDto implements ITenantCreateDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string;

    constructor(data?: ITenantCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.adminEmailAddress = _data["adminEmailAddress"] !== undefined ? _data["adminEmailAddress"] : <any>null;
            this.adminPassword = _data["adminPassword"] !== undefined ? _data["adminPassword"] : <any>null;
        }
    }

    static fromJS(data: any): TenantCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["adminEmailAddress"] = this.adminEmailAddress !== undefined ? this.adminEmailAddress : <any>null;
        data["adminPassword"] = this.adminPassword !== undefined ? this.adminPassword : <any>null;
        return data;
    }
}

export interface ITenantCreateDto {
    extraProperties?: { [key: string]: any; } | null;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
}

export class TenantDto implements ITenantDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    id?: string;
    name?: string | null;
    concurrencyStamp?: string | null;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface ITenantDto {
    extraProperties?: { [key: string]: any; } | null;
    id?: string;
    name?: string | null;
    concurrencyStamp?: string | null;
}

export class TenantUpdateDto implements ITenantUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | null;
    name!: string;
    concurrencyStamp?: string | null;

    constructor(data?: ITenantUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any): TenantUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data;
    }
}

export interface ITenantUpdateDto {
    extraProperties?: { [key: string]: any; } | null;
    name: string;
    concurrencyStamp?: string | null;
}

export class UserData implements IUserData {
    id?: string;
    tenantId?: string | null;
    userName?: string | null;
    name?: string | null;
    surname?: string | null;
    isActive?: boolean;
    email?: string | null;
    emailConfirmed?: boolean;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    readonly extraProperties?: { [key: string]: any; } | null;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key] !== undefined ? _data["extraProperties"][key] : <any>null;
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IUserData {
    id?: string;
    tenantId?: string | null;
    userName?: string | null;
    name?: string | null;
    surname?: string | null;
    isActive?: boolean;
    email?: string | null;
    emailConfirmed?: boolean;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    extraProperties?: { [key: string]: any; } | null;
}

export class IStringValueType implements IIStringValueType {
    readonly name?: string | null;
    readonly properties?: { [key: string]: any; } | null;
    validator?: IValueValidator;

    constructor(data?: IIStringValueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] !== undefined ? _data["properties"][key] : <any>null;
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>null;
        }
    }

    static fromJS(data: any): IStringValueType {
        data = typeof data === 'object' ? data : {};
        let result = new IStringValueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>null;
        return data;
    }
}

export interface IIStringValueType {
    name?: string | null;
    properties?: { [key: string]: any; } | null;
    validator?: IValueValidator;
}

export class IValueValidator implements IIValueValidator {
    readonly name?: string | null;
    readonly properties?: { [key: string]: any; } | null;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] !== undefined ? _data["properties"][key] : <any>null;
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name?: string | null;
    properties?: { [key: string]: any; } | null;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}